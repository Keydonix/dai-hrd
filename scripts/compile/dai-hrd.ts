import * as path from 'path'
import { promises as fs } from 'fs'
import { ethereum } from '@zoltu/ethereum-crypto'
import { compile } from './helpers'
import { contractsDirectory } from '../libraries/paths'

export async function compileDaiHrd(daiAddress: bigint, potAddress: bigint, vatAddress: bigint, daiJoinAddress: bigint, getNextUniswapExchangeAddress: (token: bigint) => Promise<bigint>) {
	const runtimeConstantsSource = await generateRuntimeConstants(daiAddress, potAddress, vatAddress, daiJoinAddress, getNextUniswapExchangeAddress)
	await compile('dai-hrd', [
		'@openzeppelin/contracts/GSN/Context.sol',
		'@openzeppelin/contracts/token/ERC20/IERC20.sol',
		'@openzeppelin/contracts/token/ERC777/IERC777.sol',
		'@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol',
		'@openzeppelin/contracts/token/ERC777/IERC777Sender.sol',
		'@openzeppelin/contracts/math/SafeMath.sol',
		'@openzeppelin/contracts/utils/Address.sol',
		'@openzeppelin/contracts/introspection/IERC1820Registry.sol',
		'dai.sol',
		'lib.sol',
		'join.sol',
		'pot.sol',
		'vat.sol',
		'DaiHrd.sol',
		['RuntimeConstants.sol', runtimeConstantsSource],
	])
}

async function generateRuntimeConstants(daiAddress: bigint, potAddress: bigint, vatAddress: bigint, daiJoinAddress: bigint, getNextUniswapExchangeAddress: (token: bigint) => Promise<bigint>) {
	// guess what the next uniswap exchange address is by simulating a call to `createExchange` with a placeholder address
	const uniswapExchangeAddress = await getNextUniswapExchangeAddress(0xadd12e55add12e55add12e55add12e55add12e55n)
	const contents = `// THIS FILE IS AUTOGENERATED DURING MIGRATION, DO NOT EDIT BY HAND
pragma solidity 0.5.12;

import { Dai } from "./dai.sol";
import { DaiJoin } from "./join.sol";
import { Pot } from "./pot.sol";
import { Vat } from "./vat.sol";

contract RuntimeConstants {
	Dai constant public dai = Dai(0x${await ethereum.addressToChecksummedString(daiAddress)});
	Vat constant public vat = Vat(0x${await ethereum.addressToChecksummedString(vatAddress)});
	Pot constant public pot = Pot(0x${await ethereum.addressToChecksummedString(potAddress)});
	DaiJoin constant public daiJoin = DaiJoin(0x${await ethereum.addressToChecksummedString(daiJoinAddress)});
	address constant public uniswapExchange = 0x${await ethereum.addressToChecksummedString(uniswapExchangeAddress)};
}
`
	await fs.writeFile(path.join(contractsDirectory, 'RuntimeConstants.sol'), contents)
	return contents
}
